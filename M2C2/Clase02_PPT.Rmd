---
title: "Herramientas para el Big Data - Clase 02"
subtitle: "Diplomado Big Data para Políticas Públicas"
author: "Pablo Aguirre Hormann"
date: "04/07/2020"
output: 
  ioslides_presentation:
    widescreen: true
    #smaller: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE,
  error = FALSE,
  fig.align = 'center',
  out.width='60%')

library(readr)
library(tidyverse)
library(countdown)
library(flair)

datosONU_tidy <- read_csv("datos/DatosONU_tidy.csv")
```

# Repaso de ayer

## Repliquen el siguiente gráfico

```{r, echo = FALSE, out.width='80%'}
ggplot(iris, aes(x = Sepal.Width, y = Sepal.Length, col = Species)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  labs(
    title = "Relación entre ancho y largo de sépalo",
    x = "Ancho de sépalo (mm)",
    y = "Largo de sépalo (mm)"
  ) +
  theme_minimal()
```

## Recuerden {.smaller}

- Cualquier duda sobre alguna función `?nombrefunción`
- Dentro de `aes` van las variables/columnas que influyen en las características del gráfico
- Lo definido en `aes` dentro de `ggplot` influirá todos los `geom`
- Con `+` agregan las "capas" del gráfico
- Noten que las lineas de tendencia no incluyen intervalo/banda de confianza
- Función `labs` para títulos y ejes
- `theme_minimal`

```{r, echo = FALSE, out.width='50%'}
ggplot(iris, aes(x = Sepal.Width, y = Sepal.Length, col = Species)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  labs(
    title = "Relación entre ancho y largo de sépalo",
    x = "Ancho de sépalo (mm)",
    y = "Largo de sépalo (mm)"
  ) +
  theme_minimal()
```

## Ejercicio (i)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.1.PrimerEjercicioGrafico.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Ejercicio (ii) 

```{r, echo = FALSE}
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Respuesta {.smaller}

```{r, out.width='55%'}
ggplot(iris, aes(x = Sepal.Width, y = Sepal.Length, col = Species)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  labs(
    title = "Relación entre ancho y largo de sépalo",
    x = "Ancho de sépalo (mm)",
    y = "Largo de sépalo (mm)"
  ) +
  theme_minimal()
```

# ¿Qué veremos hoy?

## ¿Qué veremos hoy?

- Manejo de datos con `dplyr`
  * una y más tablas
- Muchas funciones

```{r, out.width='80%',  echo = FALSE, out.width='750px'}
knitr::include_graphics("Imagenes/ProcesoDS.png")
```

# Datos *tidy*

## Datos *tidy*

- Cada columna es una variable
- Cada fila es una observación
- Cada celda corresponde a un valor

```{r, out.width='80%',  echo = FALSE, out.width='750px'}
knitr::include_graphics("Imagenes/TidyData.png")
```

## *Data frames* - *Tibbles*

- El objeto que `R` usa para "almacenar planillas" es el *data frame*
- *tibble* es una "versión moderna" de un *data frame*
- En este curso hablaremos de *data frames* y *tibble* indistintamente

# Pipe

## Pipe

`%>%` nos permite definir nuestras acciones como una secuencia

- Código "anidado"
```{r, eval = FALSE}
estacionar(manejar(buscar(llaves), hacia = "trabajo"))
```

- Código como secuencia
```{r, eval = FALSE}
llaves %>% 
  buscar() %>% 
  manejar(hacia = "trabajo") %>% 
  estacionar()
```

## Ojo

- No confundir `%>%` de `dplyr` con `+` de `ggplot2`
- `%>%` nos permite tomar un output y pasarlo/encadenarlo en la siguiente operación
- `+` nos permite crear capas en un gráfico

# Manejo de datos

## Manejo de datos

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.2.ManejoDatosI.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Datos ONU (i) {.smaller}

```{r}
datosONU_tidy <- read_csv("datos/DatosONU_tidy.csv")
names(datosONU_tidy)
```

## Datos ONU (ii) {.smaller}

```{r, echo = FALSE}
datosONU_tidy <- select(datosONU_tidy,
                        -labor_force_participation_rate_female_percent_of_female_population_ages_15_modeled_ilo_estimate,
                        -public_spending_on_education_total_percent_of_government_expenditure,
                        -malnutrition_prevalence_weight_for_age_percent_of_children_under_5,
                        -health_expenditure_per_capita_ppp_constant_2005_international,
                        -poverty_headcount_ratio_at_2_a_day_ppp_percent_of_population)
```

```{r}
glimpse(datosONU_tidy)
```

## Datos ONU (iii) {.smaller}

```{r}
summary(datosONU_tidy)
```

```{r, echo = FALSE}
datosONU_tidy <- read_csv("datos/DatosONU_tidy.csv")
```

## Funciones de manipulación de datos (`dplyr`) {.smaller}

**dplyr** se basa en el concepto de funciones como verbos para manipular *data frames*

- `filter`: elige filas que cumplan criterio
- `slice`: elige filas según posición
- `mutate`: crear nuevas columnas
- `select`: elige columnas según su nombre/posición
- `arrange`: reordenar filas
- `pull`: extraer columna como vector
- `distinct`: filtra valores únicos de filas
- `rename`: cambio de nombre de columnas
- `summarise`: reducir variables a valores
- ... (muchas más)

## Reglas de `dplyr` para sus funciones

1. Primer argumento siempre es un *data frame*
2. Los siguientes argumentos describen que se hace con el *data frame*
3. El resultado siempre será un *data frame*

```{r, eval = FALSE}
funcion(datos, instruccion1, instruccion2, ...)
```

## Filtrar filas con `filter`

- Permite seleccionar un subgrupo de un *data frame*
- Permite poner muchas condiciones de forma simple

## `filter` (i) 

Solo las observaciones correspondientes a Chile

```{r}
datosONU_tidy %>% 
  filter(country_name == "Chile")
```

## `filter` (ii)

Solo las observaciones correspondientes a Chile y para años posteriores al 2000

```{r}
datosONU_tidy %>% 
  filter(country_name == "Chile", year > 2000)
```

## `filter` (iii)

Solo las observaciones correspondientes al 2000 o al 2007

```{r}
datosONU_tidy %>% 
  filter(year == 2000 | year == 2007)
```

## Operadores lógicos comúnmente usados (i) {.smaller}

Operador  Definición
--------  ----------
  `<`     menor 
  `<=`    menor o igual 
  `>`     mayor 
  `>=`    mayor o igual 
  `==`    estríctamente igual
  `!=`    distinto
  `x|y`   x O y
  `x&y`   x Y y

## Operadores lógicos comúnmente usados (ii) {.smaller}

Operador      Definición
--------      ----------
`is.na(x)`    test: valor NA (nulo)
`!is.na(x)`   test: no es valor NA (nulo)
`x %in% y`    x perteneciente a y
`!(x %in% y)` todo lo perteneciente a y que no es x
`!x`          no x

## `filter` (iv)

Solo las observaciones correspondientes a los años 1995, 2000, y 2005

```{r}
datosONU_tidy %>% 
  filter(year %in% c(1995, 2000, 2005))
```

## `filter` (v)

Solo las observaciones **NO** correspondientes a los años 1995, 2000, y 2005

```{r}
datosONU_tidy %>% 
  filter(!year %in% c(1995, 2000, 2005))
```

## `slice` para seleccionar filas por posición (i) 

La quinta fila

```{r}
datosONU_tidy %>% 
  slice(5)
```

## `slice` para seleccionar filas por posición (ii) 

Las primeras 5 filas

```{r}
datosONU_tidy %>% 
  slice(1:5)
```

## `select` para dejar solo algunas variables

Seleccionar 5 variables/columnas

```{r}
datosONU_tidy %>% 
  select(country_name, income_group, region, year, population_total)
```

## O `select` para sacar algunas variables {.smaller}

Dejar todas las columnas menos dos

```{r}
datosONU_tidy %>% 
  select(-region, -income_group)
```

## `select` tiene varias funciones "de ayuda" (i)

Dejar todas las columnas que contengan *per capita*

```{r}
datosONU_tidy %>% 
  select(contains("per_capita"))
```

## `select` tiene varias funciones "de ayuda" (ii)

Dejar todas las columnas que comiencen con *p*

```{r}
datosONU_tidy %>% 
  select(starts_with("p"))
```

## `select` tiene varias funciones "de ayuda" (iii)

Dejar todas las columnas numéricas

```{r}
datosONU_tidy %>% 
  select(where(is.numeric))
```

## `mutate` para agregar nuevas columnas (i) {.smaller}

Nueva columna calculando el logaritmo de una existente

```{r}
datosONU_tidy %>%
  select(country_name, year, co2_emissions_metric_tons_per_capita) %>% 
  mutate(log_co2_emissions = log(co2_emissions_metric_tons_per_capita))
```

## `mutate` para agregar nuevas columnas (ii) 

Columna *dummy* (binaria) para valores mayores (1) o menores (0) al promedio de la variable

```{r, eval = FALSE}
datosONU_tidy %>%
  mutate(co2_emissions_mayorquepromedio = ifelse(
    co2_emissions_metric_tons_per_capita > mean(co2_emissions_metric_tons_per_capita, 
                                                na.rm = TRUE), 1, 0)
    )
```

Sobreescribir una variable cambiando sus valores

```{r, eval = FALSE}
datosONU_tidy %>%
  mutate(income_group = case_when(
    income_group %in% c("Upper Middle Income", "Lower Middle Income") ~ "Middle Income",
    TRUE ~ income_group
    ))
```

## No olvidar "guardar" los resultados {.smaller}

Generalmente cuando generemos cambios en nuestro *dara frame* (`filter`, `select`, `mutate`) también queremos guardar el *data frame* resultante. Esto se puede hacer "sobreescribiendo" el *data frame* original o bien creando uno nuevo

Sobreescribir *data frame*

```{r, eval = FALSE}
datosONU_tidy <- datosONU_tidy %>%
  mutate(income_group = case_when(
    income_group %in% c("Upper Middle Income", "Lower Middle Income") ~ "Middle Income",
    TRUE ~ income_group
    ))
```

Crear nuevo *data frame*

```{r, eval = FALSE}
datosONU_tidy_nuevo <- datosONU_tidy %>%
  mutate(income_group = case_when(
    income_group %in% c("Upper Middle Income", "Lower Middle Income") ~ "Middle Income",
    TRUE ~ income_group
    ))
```

## `arrange` para ordenar filas según columnas (i)

```{r}
datosONU_tidy
```

## `arrange` para ordenar filas según columnas (ii)

```{r}
datosONU_tidy %>% 
  arrange(year)
```


## `pull` para extraer una columna como vector (i)

Extraer la columna como un *data frame*

```{r}
datosONU_tidy %>% 
  select(country_name)
```

## `pull` para extraer una columna como vector (ii)

Extraer la columna como un vector

```{r}
datosONU_tidy %>% 
  pull(country_name)
```

## `distinct` para dejar valores únicos (i)

Tantos valores como observaciones hay

```{r}
datosONU_tidy %>% 
  select(income_group)
```

## `distinct` para dejar valores únicos (ii)

Pero son pocos valores únicos/distintos

```{r}
datosONU_tidy %>% 
  select(income_group) %>% 
  distinct()
```

## `distinct` para dejar valores únicos (iii) {.smaller}

Se puede hacer para cualquier combinación de columnas/variables

```{r}
datosONU_tidy %>% 
  select(income_group, region) %>% 
  distinct() %>% 
  arrange(income_group, region)
```

# Ejercicio

## Ejercicio (i) {.smaller}

```{r, eval = FALSE}
# Observe los valores únicos correspondiente a "income_group"
datosONU_tidy %>% distinct(income_group)

# Genere un nuevo objeto datosONU_tidy_new seleccionando las variables country_name, income_group, year,
# gdp_per_capita_constant_2005_us y life_expectancy_at_birth_total_years
datosONU_tidy_new <- datosONU_tidy %>% 
  select(***, ***, ***, ***, ***, ***) 

# Sobreescriba el objeto datosONU_tidy_new filtrando aquellas observaciones con valores de income_group 
# igual a "Upper Middle Income" o "High Income" y año igual a 2007
datosONU_tidy_new <- datosONU_tidy_new %>% 
  filter(income_group %in% c("***", "***"),
         year *** 2007) 

# Cree una nueva variable correspondiente al logaritmo de gdp_per_capita_constant_2005_us
datosONU_tidy_new <- datosONU_tidy_new %>% 
  mutate(log_gdp_per_capita = ***(gdp_per_capita_constant_2005_us))

# Genere un gráfico de puntos (geom_point) entre log_gdp_per_capita (x) y life_expectancy_at_birth_total_years (y)
# Y permita que los puntos tengan un color distinto según el "income_group" al que pertenezcan
datosONU_tidy_new %>%
  ggplot(aes(x = ***, y = life_expectancy_at_birth_total_years, col = ***)) +
  geom_***()
```

## Ejercicio (ii)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.3.SegundoEjercicioManejoDatosI.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Ejercicio (iii)

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Respuesta {.smaller}

```{r, out.width='40%'}
datosONU_tidy %>% 
  # seleccionar variables
  select(country_name, income_group, year, gdp_per_capita_constant_2005_us, 
         life_expectancy_at_birth_total_years) %>%
  # filtrar observaciones
  filter(income_group %in% c("Upper Middle Income", "High Income"), year == 2007)  %>% 
  # crear nueva variable a partir de una de las seleccionadas
  mutate(log_gdp_per_capita = log(gdp_per_capita_constant_2005_us)) %>%
  # generar gráfico
  ggplot(aes(x = log_gdp_per_capita, y = life_expectancy_at_birth_total_years, col = income_group)) +
  geom_point()
```

# Break

## Break

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Donde vamos y que nos falta | funciones para manejar una tabla

- <span style="color:green">filter</span>: elige filas que cumplan criterio
- <span style="color:green">slice</span>: elige filas según posición
- <span style="color:green">mutate</span>: crear nuevas columnas
- <span style="color:green">select</span>: elige columnas según su nombre/posición
- <span style="color:green">arrange</span>: reordenar filas
- <span style="color:green">pull</span>: extraer columna como vector
- <span style="color:green">distinct</span>: filtra valores únicos de filas
- <span style="color:red">rename</span>: cambio de nombre de columnas
- <span style="color:red">summarise</span>: reducir variables a valores
- <span style="color:red">group_by</span>: agrupar observaciones según valores de columnas

## `rename` para cambiar nombres de columnas/variables (i) {.smaller}

Nombres muy largos

```{r}
names(datosONU_tidy)
```

## `rename` para cambiar nombres de columnas/variables (ii)

Estructura a seguir

```{r, eval = FALSE}
rename(datos, NuevoNombre = AntiguoNombre)
```

## `rename` para cambiar nombres de columnas/variables (iii) {.smaller}

Se pueden cambiar cuantos nombres queramos

```{r}
datosONU_tidy <- datosONU_tidy %>% 
  rename(
    "co2_emissions" = "co2_emissions_metric_tons_per_capita",
    "fertility_rate" = "fertility_rate_total_births_per_woman",
    "forest_area" = "forest_area_percent_of_land_area",
    "gdp_per_capita" = "gdp_per_capita_constant_2005_us",
    "health_expenditure" = "health_expenditure_per_capita_ppp_constant_2005_international",
    "labor_force_participation" = "labor_force_participation_rate_female_percent_of_female_population_ages_15_modeled_ilo_estimate",
    "life_expectancy" = "life_expectancy_at_birth_total_years",
    "malnutrition_prevalence" = "malnutrition_prevalence_weight_for_age_percent_of_children_under_5",
    "urban_population" = "urban_population_percent_of_total",
    "fossil_fuel_consumption" = "fossil_fuel_energy_consumption_percent_of_total",
    "poverty" = "poverty_headcount_ratio_at_2_a_day_ppp_percent_of_population",
    "public_spending_education" = "public_spending_on_education_total_percent_of_government_expenditure"
  )
```

## `rename` para cambiar nombres de columnas/variables (iv) {.smaller}

```{r}
names(datosONU_tidy)
```

## `summarise` para reducir variables a valores (i) {.smaller}

Número de observaciones

```{r}
datosONU_tidy %>% 
  summarise(n_observaciones = n())
```

Promedio de la columna *fertility_rate*

```{r}
datosONU_tidy %>% 
  summarise(promedio_fertility_rate = mean(fertility_rate, na.rm = TRUE))
```

## `summarise` para reducir variables a valores (ii)

Se puede calcular más de un valor

```{r}
datosONU_tidy %>% 
  summarise(n_observaciones = n(),
            promedio_fertility_rate = mean(fertility_rate, na.rm = TRUE))
```

## `group_by` para agrupar observaciones (i)

Por si sola no pasa nada

```{r}
datosONU_tidy %>% 
  group_by(region)
```

## `group_by` para agrupar observaciones (ii)

Pero con `summarise` aparecen las ventajas

```{r}
datosONU_tidy %>% 
  group_by(region) %>% 
  summarise(n_observaciones = n())
```

## `group_by` para agrupar observaciones (iii) {.smaller}

Se puede agrupar por más de una variable/columna

```{r}
datosONU_tidy %>% 
  group_by(region, income_group) %>% 
  summarise(n_observaciones = n())
```

## `count` como atajo para agrupar y contar

```{r}
datosONU_tidy %>% 
  count(region)
```

# Ejercicio

## Ejercicio (i) {.smaller}

```{r, eval = FALSE}
# Cambia el nombre de las variables a "pais", "grupo_ingresos", "anio", "total_oblacion". region no lo cambien.
datosONU_tidy_ej <- datosONU_tidy_ej %>% 
  ***(
    "pais" = "***",
    "grupo_ingresos" = "***",
    "anio" = "year",
    "total_poblacion" = "***"
  )

# ¿Cual era la poblacion mundial en 2007? (considerando los países de nuestra base)
datosONU_tidy_ej %>% 
  filter(*** == 2007) %>% 
  ***(poblacion_mundial = sum(total_poblacion, na.rm = TRUE))

# En un objeto datosONU_tidy_2007_reg guarden el resultado de calcular el total de poblacion por región
# asi como el número de países para cada region
datosONU_tidy_2007_reg <- datosONU_tidy_ej %>% 
  filter(*** == 2007) %>% 
  group_by(region) %>% 
  ***(poblacion_mundial = ***(total_poblacion, na.rm = TRUE),
            n_paises = n())

# Tomando los números recién calculados, creen una nueva columna calculando la población promedio 
# por país para cada región
datosONU_tidy_2007_reg %>% 
  ***(promedio_pob = ***/n_paises)
```

## Ejercicio (ii)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.4.TercerEjercicioManejoDatosII.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Ejercicio (iii)

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Respuesta (i) {.smaller}

```{r, echo = FALSE}
datosONU_tidy_ej <- datosONU_tidy %>% 
  select(country_name, income_group, region, year, population_total)
```

```{r}
# Cambia el nombre de las variables a "pais", "grupo_ingresos", "anio", "total_oblacion". region no lo cambien.
datosONU_tidy_ej <- datosONU_tidy_ej %>% 
  rename(
    "pais" = "country_name",
    "grupo_ingresos" = "income_group",
    "anio" = "year",
    "total_poblacion" = "population_total"
  )

# ¿Cual era la poblacion mundial en 2007? (considerando los países de nuestra base)
datosONU_tidy_ej %>% 
  filter(anio == 2007) %>% 
  summarise(poblacion_mundial = sum(total_poblacion, na.rm = TRUE))
```

## Respuesta (ii) {.smaller}

```{r}
# En un objeto datosONU_tidy_2007_reg guarden el resultado de calcular el total de poblacion por región
# asi como el número de países para cada region
datosONU_tidy_2007_reg <- datosONU_tidy_ej %>% 
  filter(anio == 2007) %>% 
  group_by(region) %>% 
  summarise(poblacion_mundial = sum(total_poblacion, na.rm = TRUE),
            n_paises = n())

# Tomando los números recién calculados, creen una nueva columna calculando la población promedio 
# por país para cada región
datosONU_tidy_2007_reg %>% 
  mutate(promedio_pob = poblacion_mundial/n_paises)
```

# Llevemos algunas de las cosas que hemos visto a otro nivel

## Funciones de ayuda (i) {.smaller}

```{r}
datosONU_tidy %>% 
  summarise(promedio_fertility_rate = mean(fertility_rate, na.rm = TRUE),
            promedio_co2_emissions = mean(co2_emissions, na.rm = TRUE),
            promedio_life_expectancy = mean(life_expectancy, na.rm = TRUE))
```

```{r}
datosONU_tidy %>% 
  summarise(
    across(c(fertility_rate, co2_emissions, life_expectancy), mean)
    )
```

## Funciones de ayuda (ii) {.smaller}

```{r}
datosONU_tidy %>% 
  summarise(
    across(c(fertility_rate, co2_emissions, life_expectancy), mean, na.rm = TRUE)
    )
```

```{r}
datosONU_tidy %>% 
  summarise(
    across(where(is.numeric), mean, na.rm = TRUE)
    )
```

## Funciones de ayuda (iii) {.smaller}

```{r}
datosONU_tidy %>% 
  summarise(
    across(c(where(is.numeric), -year), mean, na.rm = TRUE)
    )
```

## Construyamos una tabla resumen y calculemos un índice

- Calcular un índice para cada grupo de nivel de ingresos
- El índice corresponde a la suma de tres variables para cada grupo
  - *co2_emissions*
  - *fertility_rate*
  - *forest_area*

## Primero calculamos el promedio de las variables para cada grupo

```{r}
datosONU_tidy %>% 
  group_by(income_group) %>% 
  summarise(
    across(co2_emissions:forest_area, mean, na.rm = TRUE)
    )
```

## Y luego creamos una variable correspondiente al indice (i) {.smaller}

```{r}
datosONU_tidy %>% 
  group_by(income_group) %>% 
  summarise(
    across(co2_emissions:forest_area, mean, na.rm = TRUE)
    ) %>% 
  mutate(
    index = sum(c(co2_emissions, fertility_rate, forest_area))
    )
```

## Y luego creamos una variable correspondiente al indice (ii) {.smaller}

```{r}
datosONU_tidy %>% 
  group_by(income_group) %>% 
  summarise(
    across(co2_emissions:forest_area, mean, na.rm = TRUE), .groups = "keep"
    ) %>% 
  mutate(
    index = sum(c(co2_emissions, fertility_rate, forest_area))
    )
```

# Ejercicio

## Ejercicio (i)

```{r, eval = FALSE}
# Cree un nuevo objeto "datosONU_tidy_new" donde elimine aquellas columnas que contengan 
# la palabra "population" y que comiencen con la letra "f"
datosONU_tidy_new <- datosONU_tidy %>% 
  ***(-contains("***"), -starts_with("***")) 

# Calcule el promedio para todas las variables numéricas (menos "year"). Seleccione las 
# columnas usando "across" y ":" (que ayuda a seleccionar un rango de columnas)
datosONU_tidy_new %>% 
  summarise(***(c(co2_emissions:public_spending_education), mean, na.rm = ***))

# Repita lo anterior pero utilizando la funcion ayuda "where".
datosONU_tidy_new %>% 
  ***(across(***(is.numeric) & !year, mean, na.rm = ***))
```

## Ejercicio (ii)

```{r, eval = FALSE}
# Cree un nuevo objeto datosONU_tidy_new_summ realizando el mismo cálculo anterior pero
# para el año 2007 y grupando las observaciones por region e income_group
datosONU_tidy_new_summ <- datosONU_tidy_new %>% 
  ***(year == 2007) %>% 
  ***(region, income_group) %>% 
  ***(across(where(is.numeric) & !year, mean, na.rm = TRUE)) 

# Al objeto recién creado agregue una nueva columna correspondiente al log
# de "gdp_per_capita". Guarde el objeto en uno nuevo llamado "datos_plot"
datos_plot <- datosONU_tidy_new_summ %>% 
  ***(log_gdp_per_capita = ***(gdp_per_capita))

# Genere un gráfico de dispersión (puntos) entre log_gdp_per_capita (x) y co2_emissions (y)
# Diferencio los puntos según su region
datos_plot %>% 
  ggplot(aes(x = ***, y = ***, col = ***)) +
  geom_***(size = 4) +
  theme_minimal() + labs(x = "Log de GDP per capita", y = "Emisiones de CO2")
```

## Ejercicio (iii)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.5.CuartoEjercicioManejoDatosIII.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Ejercicio (iv)

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Respuesta (i)

```{r}
# Cree un nuevo objeto "datosONU_tidy_new" donde elimine aquellas columnas que contengan la palabra
# "population" y que comiencen con la letra "f"
datosONU_tidy_new <- datosONU_tidy %>% 
  select(-contains("population"), -starts_with("f")) 

# Calcule el promedio para todas las variables numéricas (menos "year")
# Seleccione las columnas usando "across" y ":" (que ayuda a seleccionar un rango de columnas)
datosONU_tidy_new %>% 
  summarise(across(c(co2_emissions:public_spending_education), mean, na.rm = TRUE))

# Repita lo anterior pero utilizando la funcion ayuda "where".
datosONU_tidy_new %>% 
  summarise(across(where(is.numeric) & !year, mean, na.rm = TRUE))
```

## Respuesta (ii)

```{r}
# Cree un nuevo objeto datosONU_tidy_new_summ realizando el mismo cálculo anterior pero
# para el año 2007 y grupando las observaciones por region e income_group
datosONU_tidy_new_summ <- datosONU_tidy_new %>% 
  filter(year == 2007) %>% 
  group_by(region, income_group) %>% 
  summarise(across(where(is.numeric) & !year, mean, na.rm = TRUE)) 

# Al objeto recién creado agregue una nueva columna correspondiente al log de "gdp_per_capita"
# guarde el objeto en uno nuevo llamado "datos_plot"
datos_plot <- datosONU_tidy_new_summ %>% 
  mutate(log_gdp_per_capita = log(gdp_per_capita))
```

## Respuesta (iii) {.smaller}

```{r}
# Genere un gráfico de dispersión (puntos) entre log_gdp_per_capita (x) y co2_emissions (y)
# Diferencio los puntos según su region
datos_plot %>% 
  ggplot(aes(x = log_gdp_per_capita, y = co2_emissions, col = region)) +
  geom_point(size = 4) +
  theme_minimal() +
  labs(x = "Log de GDP per capita", y = "Emisiones de CO2")
```

# Break

## Break

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Funciones para trabajar con dos o más *data frames* (i)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.6.ManejoDatosII.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Funciones para trabajar con dos o más *data frames* (ii)

- <span style="color:green">*mutating joins*</span>
  * `left_join`, `right_join`, `inner_join`, `full_join` 
- <span style="color:red">*filtering joins*</span>
  * `semi_join`, `anti_join`
- <span style="color:green">*set operations*</span>
  * `intersect`, `union`, `setdiff`


Más información en https://dplyr.tidyverse.org/articles/two-table.html

## *Mutating joins*

- Permiten combinar variables desde distintas tablas
- Generalmente el más utilizado es `left_join`

```{r, echo=FALSE, out.width='750px'}
knitr::include_graphics("Imagenes/Joins.png")
```

## **Left Join** (i)

Digamos que queremos calcular el promedio de *fertility_rate* para cada *income_group* pero nuestra tabla no tiene información sobre el grupo de ingresos

```{r, echo = FALSE}
income_group <- datosONU_tidy %>% 
  distinct(country_name, income_group)

countries_noincomegroup <- datosONU_tidy %>% 
  select(country_name, year, fertility_rate)
```

```{r}
countries_noincomegroup
```

## **Left Join** (ii)

Pero si tenemos otra tabla que asocia cada país a su grupo de ingresos

```{r}
income_group
```

## **Left Join** (iii)

```{r}
countries_noincomegroup %>% 
  left_join(income_group, by = "country_name")
```

## **Left Join** (iv)

```{r, echo = FALSE}
income_group2 <- datosONU_tidy %>% 
  distinct(country = country_name, income_group)
```

¿Y si los nombres no son iguales?

```{r}
names(income_group2)
```

```{r}
names(countries_noincomegroup)
```

## **Left Join** (v)

```{r}
countries_noincomegroup %>% 
  left_join(income_group2, by = c("country_name" = "country"))
```

## **Set operations** (i)

Menos usadas en general pero útiles cuando se requieren

```{r, echo=FALSE, out.width='750px'}
knitr::include_graphics("Imagenes/Set.PNG")
```

## **Set operations** (ii)

Estas funciones esperan que `x` e `y` tengan las mismas variables/columnas y compara sus observaciones/filas

- `intersect(x, y)`: devuelve solo valores que estén presentes en `x` y en `y`
- `union(x, y)`: devuelve todos los valores (únicos) de `x` y de `y`
- `setdiff(x, y)`: devuelve observaciones que estén en `x` y no en `y`
  * `setdiff(y, x)`: devuelve observaciones estén en `y` y no en `x`

```{r}
df1 <- datosONU_tidy %>% slice(1:10)
df2 <- datosONU_tidy %>% slice(5:15)
```

## **Set operations** (iii) {.smaller}

La intersección corresponde a las filas 5, 6, 7, 8, 9, y 10 de la base original

```{r}
intersect(df1, df2)
```

## **Set operations** (iv) {.smaller}

La unión corresponde a las primeras 15 filas de la base original

```{r}
union(df1, df2)
```

## **Set operations** (v) {.smaller}

Las filas que están en `df1` y no en `df2` corresponden a la 1, 2, 3, y 4 de la base original

```{r}
setdiff(df1, df2)
```

## **Set operations** (vi) {.smaller}

Las filas que están en `df2` y no en `df1` corresponden a la 11, 12, 13, 14, y 15 de la base original

```{r}
setdiff(df2, df1)
```

# Ejercicio

## Ejercicio (i)

```{r, eval = FALSE}
# Haga un left join entre "paises_sindatos" y "regiones"
# ¿Qué columna tienen en común?
# Asigne el resultado al objeto "paises_regiones"
paises_regiones <- paises_sindatos %>% 
  left_***(regiones, by = "***") 

# Haga un left join del objeto recién creado con "grupo_ingresos". 
# ¿Qué columna tienen en común? ¿tienen el mismo nombre?
# Asigne el resultado al objeto "paises_regiones_ingresos"
paises_regiones_ingresos <- paises_regiones %>% 
  ***(grupo_ingresos, by = c("***" = "***")) 

# Haga un left join del objeto recién creado con "variables"
# ¿Qué columnas tienen en común?
# Noten que el join requiere especificar dos columnas en este caso
paises_regiones_ingresos_variables <- paises_regiones_ingresos %>% 
  ***(variables, by = c("***", "***"))
```

## Ejercicio (ii)

```{r, eval=FALSE}
# ¿Qué países que estaban sobre la media de emisiones de co2 
# en 1987 lo seguían estando en 2007?
co2_sobreprom_1987 <- datosONU_tidy %>% 
  filter(*** == 1987,
         co2_emissions > ***(co2_emissions, na.rm = TRUE)) %>% 
  select(country_name)

co2_sobreprom_2007 <- datosONU_tidy %>% 
  filter(*** == 2007,
         co2_emissions > ***(co2_emissions, na.rm = TRUE)) %>% 
  select(country_name)

intersect(***, ***)
```

## Ejercicio (iii)

RStudio Cloud >> UAI-BDPP-2020-M2 >> Clase02 >> **`2.7.QuintoEjercicioManejoDatosIV.R`**

```{r, echo = FALSE}
knitr::include_url('https://rstudio.cloud/')
```

## Ejercicio (iv)

```{r, echo = FALSE}
#countdown_fullscreen(10)
knitr::include_url("https://apps.garrickadenbuie.com/countdown/")
```

## Respuesta (i)

```{r, include=FALSE, echo = FALSE}
paises_sindatos <- datosONU_tidy %>% 
  select(country_name, year)
regiones <- datosONU_tidy %>% 
  distinct(country_name, region)
grupo_ingresos <- datosONU_tidy %>% 
  distinct(country = country_name, income_group)
variables <- datosONU_tidy %>% 
  select(-income_group, -region) %>% 
  arrange(fertility_rate)
```

```{r}
# Haga un left join entre "paises_sindatos" y "regiones". ¿Qué columna tienen en común?
# Asigne el resultado al objeto "paises_regiones"
paises_regiones <- paises_sindatos %>% 
  left_join(regiones, by = "country_name") 

# Haga un left join del objeto recién creado con "grupo_ingresos". ¿Qué columna tienen en común? ¿tienen el mismo nombre?
# Asigne el resultado al objeto "paises_regiones_ingresos"
paises_regiones_ingresos <- paises_regiones %>% 
  left_join(grupo_ingresos, by = c("country_name" = "country")) 

# Haga un left join del objeto recién creado con "variables" ¿Qué columnas tienen en común?
# Noten que el join requiere especificar dos columnas en este caso
paises_regiones_ingresos_variables <- paises_regiones_ingresos %>% 
  left_join(variables, by = c("country_name", "year"))
```

## Respuesta (ii) {.smaller}

```{r}
# ¿Qué países que estaban sobre la media de emisiones de co2 en 1987 lo seguían estando en 2007?
co2_sobreprom_1987 <- datosONU_tidy %>% 
  filter(year == 1987,
         co2_emissions > mean(co2_emissions, na.rm = TRUE)) %>% 
  select(country_name)

co2_sobreprom_2007 <- datosONU_tidy %>% 
  filter(year == 2007,
         co2_emissions > mean(co2_emissions, na.rm = TRUE)) %>% 
  select(country_name)

intersect(co2_sobreprom_1987, co2_sobreprom_2007)
```
